/**
 * Receipt Graph Service
 *
 * Handles all receipt graph operations including:
 * - Creating receipt relationships
 * - Traversing the graph
 * - Finding paths between receipts
 * - Graph analytics and validation
 */

import { PrismaClient, Receipt, ReceiptRelationship, RelationType, EnterpriseTier } from '@prisma/client'
import crypto from 'crypto'

const prisma = new PrismaClient()

// Graph depth limits by tier
const GRAPH_DEPTH_LIMITS: Record<EnterpriseTier, number> = {
  FREE: 3,
  STARTER: 5,
  PRO: 10,
  ENTERPRISE: Infinity
}

export interface CreateReceiptWithGraphInput {
  // Receipt data
  enterpriseId: string
  type: 'transaction' | 'content' | 'ops'
  data: any

  // Graph relationships
  parentReceipts?: Array<{
    receiptId: string
    relationType: RelationType
    description?: string
    metadata?: Record<string, unknown>
  }>

  // Authentication
  createdBy?: string
}

export interface ReceiptGraphNode {
  receipt: Receipt
  depth: number
  path: string[] // Array of receipt IDs from root to this node
}

export interface ReceiptGraph {
  nodes: ReceiptGraphNode[]
  edges: Array<{
    from: string
    to: string
    relationType: RelationType
    description?: string
  }>
  rootReceiptId: string
  totalDepth: number
  depthLimitReached: boolean
}

/**
 * Create a receipt with optional parent relationships
 */
export async function createReceiptWithGraph(
  input: CreateReceiptWithGraphInput
): Promise<Receipt> {
  const { enterpriseId, type, data, parentReceipts, createdBy } = input

  // Calculate graph depth (max depth of any parent + 1)
  let graphDepth = 0
  if (parentReceipts && parentReceipts.length > 0) {
    const parentIds = parentReceipts.map(p => p.receiptId)
    const parents = await prisma.receipt.findMany({
      where: { id: { in: parentIds } },
      select: { graphDepth: true }
    })

    if (parents.length !== parentIds.length) {
      throw new Error('One or more parent receipts not found')
    }

    graphDepth = Math.max(...parents.map(p => p.graphDepth)) + 1
  }

  // Generate graph hash (includes parent IDs for integrity)
  const parentIdsSorted = parentReceipts
    ? parentReceipts.map(p => p.receiptId).sort()
    : []
  const graphHashInput = JSON.stringify(parentIdsSorted)
  const graphHash = crypto
    .createHash('sha256')
    .update(graphHashInput)
    .digest('hex')

  // Create receipt with graph fields
  const receipt = await prisma.receipt.create({
    data: {
      enterpriseId,
      type: type.toUpperCase() as any,
      transactionId: crypto.randomUUID(),
      transactionData: data,
      cryptographicProof: {}, // This would be generated by signing service
      graphDepth,
      graphHash
    }
  })

  // Create relationships if parent receipts provided
  if (parentReceipts && parentReceipts.length > 0) {
    await Promise.all(
      parentReceipts.map(parent =>
        prisma.receiptRelationship.create({
          data: {
            parentReceiptId: parent.receiptId,
            childReceiptId: receipt.id,
            relationType: parent.relationType,
            description: parent.description,
            metadata: parent.metadata as any,
            createdBy
          }
        })
      )
    )
  }

  return receipt
}

/**
 * Get receipt graph starting from a specific receipt
 * Respects tier-based depth limits
 */
export async function getReceiptGraph(
  receiptId: string,
  enterpriseTier: EnterpriseTier,
  direction: 'ancestors' | 'descendants' | 'both' = 'both'
): Promise<ReceiptGraph> {
  const maxDepth = GRAPH_DEPTH_LIMITS[enterpriseTier]
  const visited = new Set<string>()
  const nodes: ReceiptGraphNode[] = []
  const edges: Array<{
    from: string
    to: string
    relationType: RelationType
    description?: string
  }> = []

  let depthLimitReached = false

  async function traverse(
    id: string,
    currentDepth: number,
    path: string[]
  ): Promise<void> {
    if (visited.has(id)) return
    if (currentDepth > maxDepth) {
      depthLimitReached = true
      return
    }

    visited.add(id)
    const newPath = [...path, id]

    // Get receipt
    const receipt = await prisma.receipt.findUnique({
      where: { id }
    })

    if (!receipt) return

    nodes.push({
      receipt,
      depth: currentDepth,
      path: newPath
    })

    // Get parent relationships if looking at ancestors
    if (direction === 'ancestors' || direction === 'both') {
      const parentRels = await prisma.receiptRelationship.findMany({
        where: { childReceiptId: id },
        include: { parentReceipt: true }
      })

      for (const rel of parentRels) {
        edges.push({
          from: rel.parentReceiptId,
          to: rel.childReceiptId,
          relationType: rel.relationType,
          description: rel.description || undefined
        })
        await traverse(rel.parentReceiptId, currentDepth + 1, newPath)
      }
    }

    // Get child relationships if looking at descendants
    if (direction === 'descendants' || direction === 'both') {
      const childRels = await prisma.receiptRelationship.findMany({
        where: { parentReceiptId: id },
        include: { childReceipt: true }
      })

      for (const rel of childRels) {
        edges.push({
          from: rel.parentReceiptId,
          to: rel.childReceiptId,
          relationType: rel.relationType,
          description: rel.description || undefined
        })
        await traverse(rel.childReceiptId, currentDepth + 1, newPath)
      }
    }
  }

  await traverse(receiptId, 0, [])

  return {
    nodes,
    edges,
    rootReceiptId: receiptId,
    totalDepth: Math.max(...nodes.map(n => n.depth), 0),
    depthLimitReached
  }
}

/**
 * Find all paths between two receipts
 */
export async function findPathsBetweenReceipts(
  startReceiptId: string,
  endReceiptId: string,
  maxPaths: number = 10
): Promise<Array<{ path: string[], relationships: ReceiptRelationship[] }>> {
  const paths: Array<{ path: string[], relationships: ReceiptRelationship[] }> = []
  const visited = new Set<string>()

  async function dfs(
    currentId: string,
    targetId: string,
    currentPath: string[],
    currentRels: ReceiptRelationship[]
  ): Promise<void> {
    if (paths.length >= maxPaths) return
    if (visited.has(currentId)) return

    visited.add(currentId)
    const newPath = [...currentPath, currentId]

    if (currentId === targetId) {
      paths.push({
        path: newPath,
        relationships: currentRels
      })
      visited.delete(currentId)
      return
    }

    // Search through child relationships
    const childRels = await prisma.receiptRelationship.findMany({
      where: { parentReceiptId: currentId }
    })

    for (const rel of childRels) {
      await dfs(
        rel.childReceiptId,
        targetId,
        newPath,
        [...currentRels, rel]
      )
    }

    visited.delete(currentId)
  }

  await dfs(startReceiptId, endReceiptId, [], [])
  return paths
}

/**
 * Get graph analytics for an enterprise
 */
export async function getGraphAnalytics(enterpriseId: string) {
  const [
    totalReceipts,
    totalRelationships,
    receiptsByType,
    relationshipsByType,
    maxDepth,
    orphanedReceipts
  ] = await Promise.all([
    // Total receipts
    prisma.receipt.count({
      where: { enterpriseId }
    }),

    // Total relationships
    prisma.receiptRelationship.count({
      where: {
        parentReceipt: { enterpriseId }
      }
    }),

    // Receipts by type
    prisma.receipt.groupBy({
      by: ['type'],
      where: { enterpriseId },
      _count: true
    }),

    // Relationships by type
    prisma.receiptRelationship.groupBy({
      by: ['relationType'],
      where: {
        parentReceipt: { enterpriseId }
      },
      _count: true
    }),

    // Max depth
    prisma.receipt.findFirst({
      where: { enterpriseId },
      orderBy: { graphDepth: 'desc' },
      select: { graphDepth: true }
    }),

    // Orphaned receipts (no parents or children)
    prisma.receipt.findMany({
      where: {
        enterpriseId,
        AND: [
          { parentRelationships: { none: {} } },
          { childRelationships: { none: {} } }
        ]
      },
      select: { id: true, type: true, createdAt: true }
    })
  ])

  return {
    totalReceipts,
    totalRelationships,
    receiptsByType: receiptsByType.map(r => ({
      type: r.type,
      count: r._count
    })),
    relationshipsByType: relationshipsByType.map(r => ({
      type: r.relationType,
      count: r._count
    })),
    maxDepth: maxDepth?.graphDepth || 0,
    orphanedReceipts: {
      count: orphanedReceipts.length,
      receipts: orphanedReceipts
    }
  }
}

/**
 * Validate graph integrity
 * Checks for cycles, broken references, etc.
 */
export async function validateGraphIntegrity(enterpriseId: string) {
  const issues: string[] = []

  // Check for cycles (receipts that reference themselves in ancestor chain)
  const receipts = await prisma.receipt.findMany({
    where: { enterpriseId },
    include: {
      parentRelationships: true,
      childRelationships: true
    }
  })

  for (const receipt of receipts) {
    const ancestors = new Set<string>()
    const queue = [receipt.id]

    while (queue.length > 0) {
      const currentId = queue.shift()!
      if (ancestors.has(currentId)) {
        issues.push(`Cycle detected: Receipt ${receipt.id} has itself in ancestor chain`)
        break
      }
      ancestors.add(currentId)

      const parentRels = await prisma.receiptRelationship.findMany({
        where: { childReceiptId: currentId }
      })

      queue.push(...parentRels.map(r => r.parentReceiptId))
    }
  }

  return {
    valid: issues.length === 0,
    issues
  }
}

export { GRAPH_DEPTH_LIMITS }