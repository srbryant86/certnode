<!-- File: web/pitch.html -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CertNode  Receipts for Digital Truth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="CertNode gives digital data a tamper-evident receipt you can verify offline."/>
  <style>
    :root { --bg:#0b0c10; --panel:#111218; --ink:#e6e7ee; --muted:#a9abbb; --accent:#7dd3fc; --line:#202231; }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Inter,Ubuntu,Cantarell,"Helvetica Neue","Noto Sans",Arial,sans-serif}
    a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
    .wrap{max-width:980px;margin:0 auto;padding:32px 20px}
    .hero{padding:28px; border:1px solid var(--line); background:linear-gradient(180deg,#11131b, #0d0f17)}
    h1{margin:0 0 10px 0; font-size:28px; letter-spacing:0.2px}
    .tag{display:inline-block; font-size:12px; letter-spacing:.6px; text-transform:uppercase; color:#8aa0ff; background:#12162a; border:1px solid #243066; padding:4px 8px; border-radius:999px}
    .grid{display:grid; gap:18px; grid-template-columns:1fr}
    @media(min-width:880px){ .grid{grid-template-columns:1fr 1fr} }
    section{border:1px solid var(--line); background:var(--panel); padding:20px}
    h2{margin:0 0 8px 0; font-size:18px}
    h3{margin:12px 0 6px 0; font-size:15px; color:#bfc2d8}
    ul{margin:8px 0 0 18px; padding:0}
    .muted{color:var(--muted)}
    .mono{font-family: ui-monospace,SFMono-Regular,Consolas,Monaco,Menlo,monospace; font-size:13px}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid var(--line); background:#0f111a}
    .faq q{quotes:"" "" "" ""} .faq q:before{content:open-quote} .faq q:after{content:close-quote}
    .cta{display:flex; gap:12px; flex-wrap:wrap; margin-top:12px}
    .btn{display:inline-block; border:1px solid #284469; background:#0f1a28; color:#cfe7ff; padding:10px 14px; border-radius:8px}
    .btn:hover{background:#112036}
    .kbd{border:1px solid var(--line); background:#0e1017; padding:1px 6px; border-radius:6px}
    .foot{margin-top:24px; color:var(--muted); font-size:13px}
    .codebox{border:1px dashed #2a2c3b; background:#0f1117; padding:12px; overflow:auto}
    .ok{color:#8cffc9}
    .warn{color:#ffd18a}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    input[type="text"], textarea{width:100%; background:#0f1117; border:1px solid #2a2c3b; color:var(--ink); padding:8px 10px; border-radius:6px}
    textarea{min-height:120px}
    small.mono{display:block; margin-top:6px; color:#9aa3b2}
  </style>
</head>
<body>
  <div class="wrap">

    <div class="hero">
      <div class="tag">CertNode</div>
      <h1>Receipts for Digital Truth</h1>
      <p class="muted">CertNode gives any JSON or document a <strong>tamper-evident receipt</strong>. If someone edits it later, the receipt wont match  anyone can verify that offline in seconds.</p>
      <div class="cta">
        <a class="btn" href="#demo">Try a 60-second demo</a>
        <a class="btn" href="#scripts">How to explain it</a>
        <a class="btn" href="#decoder">Acronyms, in plain English</a>
      </div>
    </div>

    <div class="grid" style="margin-top:18px">
      <section>
        <h2>10 seconds</h2>
        <p><strong>CertNode puts a tamper-evident receipt on digital stuff.</strong> If it changes, the receipt breaks.</p>
      </section>
      <section>
        <h2>30 seconds</h2>
        <p>Online files and API payloads are easy to tweak. CertNode stamps the exact bytes with a receipt and publishes public keys. Later, anyone can check <em>offline</em> that its the same version that was issued.</p>
      </section>
    </div>

    <section>
      <h2>Two-minute story</h2>
      <h3>Problem</h3>
      <ul>
        <li>AI text, invoices, API results  <em>easy to edit</em> without leaving a trace.</li>
        <li>Disputes, audits, and who changed this? slow teams down.</li>
      </ul>
      <h3>What CertNode does</h3>
      <ul>
        <li>Signs the data and returns a <span class="pill">receipt</span> that only matches that exact version.</li>
        <li>Publishes <span class="pill">public keys</span> so anyone can verify without calling us.</li>
      </ul>
      <h3>Why it matters</h3>
      <ul>
        <li>Prove <strong>nothing changed</strong> to bosses, customers, or regulators.</li>
        <li>Fast, cheap insurance against messy disputes.</li>
      </ul>
    </section>

    <div class="grid">
      <section>
        <h2>Everyday uses</h2>
        <ul>
          <li><strong>Invoices / payouts:</strong> We paid these exact numbers.</li>
          <li><strong>Webhooks / APIs:</strong> This payload wasnt altered in transit.</li>
          <li><strong>Policies / PDFs:</strong> This is the exact version we published.</li>
          <li><strong>AI outputs:</strong> This is the approved result, unchanged.</li>
        </ul>
      </section>
      <section id="scripts">
        <h2>How to say it</h2>
        <ul>
          <li><strong>One-liner:</strong> Its a <em>receipt for data integrity</em>  change the data and the receipt breaks.</li>
          <li><strong>Analogy:</strong> Like a tamper-evident sticker on a box  but for files.</li>
          <li><strong>Skeptic:</strong> You dont have to trust us  verification works offline with our public keys.</li>
        </ul>
      </section>
    </div>

    <section id="decoder">
      <h2>Acronyms, decoded</h2>
      <ul>
        <li><strong>ES256</strong>  a modern digital signature (fast, standard).</li>
        <li><strong>JWS</strong>  the receipt format (the signed bundle).</li>
        <li><strong>JWKS</strong>  our public key list (to verify receipts).</li>
        <li><strong>KMS</strong>  AWSs key vault; private keys never leave it.</li>
        <li><strong>JCS / RFC 8785</strong>  a strict JSON format so <code>1,2,3</code> is always written the same before signing.</li>
        <li><strong>RFC 3161 timestamp</strong>  a third-party notary timestamp (optional).</li>
        <li><strong>Merkle proof</strong>  shows your item is in a daily log without revealing other items (optional).</li>
      </ul>
      <p class="muted">Translation: a standard signature, a standard receipt, and a public key list so anyone can check later.</p>
    </section>

    <section id="demo">
      <h2>Try it in 60 seconds</h2>
      <p class="muted">This in-browser demo uses an <em>ephemeral</em> P-256 key (for illustration only). In production, CertNode signs inside AWS KMS and serves public keys via CloudFront.</p>

      <div class="row" style="margin:8px 0">
        <button class="btn" id="genKey">1) Generate key</button>
        <button class="btn" id="signBtn" disabled>2) Sign payload</button>
        <button class="btn" id="verifyBtn" disabled>3) Verify</button>
        <button class="btn" id="mutateBtn" disabled>Mutate payload</button>
      </div>

      <label class="muted">Payload (JSON)</label>
      <textarea id="payloadBox" class="mono">{"hello":"world","n":42}</textarea>

      <div style="margin-top:10px" class="grid">
        <section>
          <h3>Receipt (detached JWS parts)</h3>
          <div class="codebox mono" id="receiptBox"></div>
          <small class="mono">payload_jcs_sha256: <span id="plHash"></span></small>
          <small class="mono">receipt_id: <span id="rid"></span></small>
        </section>
        <section>
          <h3>Status</h3>
          <div class="codebox mono" id="statusBox">Waiting</div>
        </section>
      </div>
    </section>

    <p class="foot"> CertNode  This is a developer preview page. Production verification uses our edge-hosted JWKS with rotation.</p>
  </div>

<script>
/* Minimal helpers: base64url, JCS, RFC7638 thumbprint, WebCrypto ES256 demo */
const b64u = (buf) => {
  const b64 = (buf instanceof ArrayBuffer ? Buffer.from(buf) : Buffer.from(buf))
    .toString('base64').replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  return b64;
};

function isObj(v){ return v && typeof v==='object' && !Array.isArray(v); }
function jcsStringify(v){
  if (v === null || typeof v === 'number' || typeof v === 'boolean' || typeof v === 'string') return JSON.stringify(v);
  if (Array.isArray(v)) return '['+v.map(jcsStringify).join(',')+']';
  if (isObj(v)) {
    const keys = Object.keys(v).filter(k => typeof v[k] !== 'undefined').sort();
    return '{'+keys.map(k => JSON.stringify(k)+':'+jcsStringify(v[k])).join(',')+'}';
  }
  return JSON.stringify(v);
}
function jcsBytes(v){ return new TextEncoder().encode(jcsStringify(v)); }

async function sha256(buf){
  return new Uint8Array(await crypto.subtle.digest('SHA-256', buf));
}

function jwkThumbprint(jwk){
  if (!jwk || jwk.kty!=='EC' || jwk.crv!=='P-256') throw new Error('Thumbprint needs EC P-256');
  const json = JSON.stringify({crv:jwk.crv,kty:jwk.kty,x:jwk.x,y:jwk.y});
  return b64u(sha256(new TextEncoder().encode(json)));
}

// DER -> JOSE (r||s), very small parser for P-256
function derToJose(derBuf){
  const der = new Uint8Array(derBuf);
  let i=0; if(der[i++]!==0x30) throw Error('DER: no seq'); i++; // len (assume <128)
  if(der[i++]!==0x02) throw Error('DER: no int r'); let rLen=der[i++]; let r=der.slice(i,i+rLen); i+=rLen;
  if(der[i++]!==0x02) throw Error('DER: no int s'); let sLen=der[i++]; let s=der.slice(i,i+sLen);
  if(r[0]===0x00 && r.length>32) r=r.slice(1); if(s[0]===0x00 && s.length>32) s=s.slice(1);
  if(r.length>32||s.length>32) throw Error('r/s too long');
  const pad = (a)=>{ const out=new Uint8Array(32); out.set(a, 32-a.length); return out; };
  const out = new Uint8Array(64); out.set(pad(r),0); out.set(pad(s),32); return out;
}

const state = { keyPair:null, pubJwk:null };

const $ = (id)=>document.getElementById(id);
const ui = {
  payload: $('payloadBox'), genKey:$('genKey'), sign:$('signBtn'), verify:$('verifyBtn'), mutate:$('mutateBtn'),
  receipt:$('receiptBox'), status:$('statusBox'), plHash:$('plHash'), rid:$('rid')
};

ui.genKey.onclick = async () => {
  ui.status.textContent = 'Generating P-256 key';
  state.keyPair = await crypto.subtle.generateKey({name:'ECDSA', namedCurve:'P-256'}, true, ['sign','verify']);
  state.pubJwk = await crypto.subtle.exportKey('jwk', state.keyPair.publicKey);
  ui.genKey.disabled = true; ui.sign.disabled = false; ui.status.textContent = 'Key ready.';
};

ui.sign.onclick = async () => {
  try {
    const payload = JSON.parse(ui.payload.value);
    const jcs = jcsBytes(payload);
    const payloadB64 = b64u(jcs);
    const plHash = b64u(await sha256(jcs));
    ui.plHash.textContent = plHash;

    const kid = (await jwkThumbprint(state.pubJwk));
    const protectedHeader = { alg:'ES256', kid };
    const protectedB64 = b64u(new TextEncoder().encode(JSON.stringify(protectedHeader)));
    const signingInput = new TextEncoder().encode(`${protectedB64}.${payloadB64}`);

    const der = await crypto.subtle.sign({name:'ECDSA', hash:'SHA-256'}, state.keyPair.privateKey, signingInput);
    const joseSig = b64u(derToJose(der));
    const rid = b64u(await sha256(new TextEncoder().encode(`${protectedB64}.${payloadB64}.${joseSig}`)));
    ui.rid.textContent = rid;

    ui.receipt.textContent = JSON.stringify({
      protected: protectedB64, signature: joseSig, kid, payload
    }, null, 2);

    ui.verify.disabled = false; ui.mutate.disabled = false;
    ui.status.innerHTML = '<span class="ok">Signed  try Verify, then tweak the payload.</span>';
  } catch (e) {
    ui.status.innerHTML = '<span class="warn">Error: '+(e.message||e)+'</span>';
  }
};

ui.verify.onclick = async () => {
  try {
    const r = JSON.parse(ui.receipt.textContent);
    const jcs = jcsBytes(r.payload);
    const payloadB64 = b64u(jcs);
    const protectedB64 = r.protected;
    const signingInput = new TextEncoder().encode(`${protectedB64}.${payloadB64}`);

    // import public key from current ephemeral JWK
    const pubKey = await crypto.subtle.importKey('jwk', state.pubJwk, {name:'ECDSA', namedCurve:'P-256'}, true, ['verify']);

    // Convert JOSE sig back to DER for verify: small helper
    function joseToDer(joseB64){
      const sig = Buffer.from(joseB64.replace(/-/g,'+').replace(/_/g,'/'),'base64');
      const r = sig.subarray(0,32); const s = sig.subarray(32,64);
      function strip(b){ let i=0; while(i<b.length-1 && b[i]===0) i++; return b.subarray(i); }
      const rS=strip(r), sS=strip(s);
      const mk = (v)=> v[0]&0x80 ? Buffer.concat([Buffer.from([0]),v]) : v;
      const R=mk(rS), S=mk(sS);
      const der = Buffer.concat([Buffer.from([0x30, 4+R.length+S.length, 0x02, R.length]), R, Buffer.from([0x02, S.length]), S]);
      return der;
    }

    const derSig = joseToDer(r.signature);
    const ok = await crypto.subtle.verify({name:'ECDSA', hash:'SHA-256'}, pubKey, derSig, signingInput);
    ui.status.innerHTML = ok ? '<span class="ok">RECEIPT OK  signature matches payload</span>'
                             : '<span class="warn">RECEIPT MISMATCH  payload or receipt changed</span>';
  } catch (e) {
    ui.status.innerHTML = '<span class="warn">Verify error: '+(e.message||e)+'</span>';
  }
};

ui.mutate.onclick = () => {
  try {
    const obj = JSON.parse(ui.payload.value);
    obj._touched = (obj._touched||0)+1;
    ui.payload.value = JSON.stringify(obj, null, 2);
    ui.status.innerHTML = '<span class="warn">Payload changed  verify should now fail.</span>';
  } catch(e) {
    ui.status.innerHTML = '<span class="warn">Cant mutate: invalid JSON.</span>';
  }
};
</script>
</body>
</html>
